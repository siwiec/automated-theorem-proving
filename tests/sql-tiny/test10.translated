% Equivallence check for file tests/sql-tiny/test10.sql...
% CREATE TABLE tab (
%   fst NUMBER(4),
%   snd NUMBER(4),
%   trd NUMBER(4),
%   CONSTRAINT tab_pk PRIMARY KEY (fst, snd)
% );
% 
% 
% SELECT c.snd, a.fst
% FROM tab AS a,
%      (SELECT tab.snd, tab.fst from tab) AS c
% WHERE
%     c.fst = a.snd
%     AND c.snd = a.snd

% Database scheme:
% tab:
%	fst: Number
%	snd: Number
%	trd: Number

% Translating query 0...
% SelectStatement
%   Select
%     { qeSetQuantifier = SQDefault
%     , qeSelectList =
%         [ ( Iden [ Name Nothing "c" , Name Nothing "snd" ] , Nothing )
%         , ( Iden [ Name Nothing "a" , Name Nothing "fst" ] , Nothing )
%         ]
%     , qeFrom =
%         [ TRAlias
%             (TRSimple [ Name Nothing "tab" ])
%             (Alias (Name Nothing "a") Nothing)
%         , TRAlias
%             (TRQueryExpr
%                Select
%                  { qeSetQuantifier = SQDefault
%                  , qeSelectList =
%                      [ ( Iden [ Name Nothing "tab" , Name Nothing "snd" ] , Nothing )
%                      , ( Iden [ Name Nothing "tab" , Name Nothing "fst" ] , Nothing )
%                      ]
%                  , qeFrom = [ TRSimple [ Name Nothing "tab" ] ]
%                  , qeWhere = Nothing
%                  , qeGroupBy = []
%                  , qeHaving = Nothing
%                  , qeOrderBy = []
%                  , qeOffset = Nothing
%                  , qeFetchFirst = Nothing
%                  })
%             (Alias (Name Nothing "c") Nothing)
%         ]
%     , qeWhere =
%         Just
%           (BinOp
%              (BinOp
%                 (Iden [ Name Nothing "c" , Name Nothing "fst" ])
%                 [ Name Nothing "=" ]
%                 (Iden [ Name Nothing "a" , Name Nothing "snd" ]))
%              [ Name Nothing "and" ]
%              (BinOp
%                 (Iden [ Name Nothing "c" , Name Nothing "snd" ])
%                 [ Name Nothing "=" ]
%                 (Iden [ Name Nothing "a" , Name Nothing "snd" ])))
%     , qeGroupBy = []
%     , qeHaving = Nothing
%     , qeOrderBy = []
%     , qeOffset = Nothing
%     , qeFetchFirst = Nothing
%     }

fof(main_query_0_definition_0, definition, ( ! [A_FST, C_FST, C_SND] : ((( main_query_0(A_FST, C_FST, C_SND)) <=> ( ? [A_SND, A_TRD] : (((( tab(A_FST, A_SND, A_TRD)) & (( ? [C_FST, C_SND, C_TRD] : (((( tab(C_FST, C_SND, C_TRD)) & $true) & $true))) & $true)) & ((C_FST = A_SND) & (C_SND = A_SND))))))))).

fof(tab_substitution_1, axiom, ( ! [X_0, X_1, X_2, X_3] : ((((X_0 = X_1) & ( tab(X_1, X_2, X_3))) => ( tab(X_0, X_2, X_3)))))).

fof(tab_substitution_2, axiom, ( ! [X_0, X_1, X_2, X_3] : ((((X_0 = X_2) & ( tab(X_1, X_2, X_3))) => ( tab(X_1, X_0, X_3)))))).

fof(tab_substitution_3, axiom, ( ! [X_0, X_1, X_2, X_3] : ((((X_0 = X_3) & ( tab(X_1, X_2, X_3))) => ( tab(X_1, X_2, X_0)))))).

fof(lessThanOrEqual_substitution_1, axiom, ( ! [X_0, X_1, X_2] : ((((X_0 = X_1) & ( lessthanorequal(X_1, X_2))) => ( lessthanorequal(X_0, X_2)))))).

fof(lessThanOrEqual_substitution_2, axiom, ( ! [X_0, X_1, X_2] : ((((X_0 = X_2) & ( lessthanorequal(X_1, X_2))) => ( lessthanorequal(X_1, X_0)))))).

fof(reflexivity_of_equality, axiom, ( ! [X] : ((X = X)))).

fof(symmetry_of_equality, axiom, ( ! [X, Y] : (((X = Y) => (Y = X))))).

fof(transitivity_of_equality, axiom, ( ! [X, Y, Z] : ((((X = Y) & (Y = Z)) => (X = Z))))).

fof(reflexivity_of_less_than_or_equal, axiom, ( ! [X] : (( lessthanorequal(X, X))))).

fof(antisymmetry_of_less_than_or_equal, axiom, ( ! [X, Y] : (((( lessthanorequal(X, Y)) & ( lessthanorequal(Y, X))) => (X = Y))))).

fof(transitivity_of_less_than_or_equal, axiom, ( ! [X, Y, Z] : (((( lessthanorequal(X, Y)) & ( lessthanorequal(Y, Z))) => ( lessthanorequal(X, Z)))))).

